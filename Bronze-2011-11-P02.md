```clojure
^{:nextjournal.clerk/visibility #{:hide-ns}}
(ns Bronze-2011-11-P02
  (:require [common]
            [nextjournal.clerk :as clerk]))
{:nextjournal.clerk/visibility {:code :hide}}
(clerk/html [:style (slurp "common.css")])
```

## Bronze-2011-11-P02

# 尴尬的数字 [Brian Dean]

## 题目

奶牛贝西正在学习如何在不同的基数之间转换数字, 但由于她不能轻易地在她的两个前蹄之间握住一支笔, 所以她总是会犯错误.

每当贝西将一个数字转换为新的基数并写下结果时, 她总是会写错一个数字. 例如, 如果她将数字 $14$ 转换为二进制, 正确的结果应该是 `"1110"`, 但她可能会写成 `"0110"` 或 `"1111"`. 贝西从不会意外地添加或删除数字, 所以如果这是她写错的数字, 她可能会写下一个以 `"0"` 开头的数字.

给定贝西将一个数字 $N$ 转换为二进制和三进制时的输出, 请确定 $N$ 的正确原始值（在基数 $10$ 中）. 你可以假设 $N$ 最多为 $10$ 亿, 并且 $N$ 的解是唯一的.

如果你对二进制和三进制的数字不熟悉, 欢迎你查阅任何你想要的在线参考资料.

**问题名称:** `digits`

**输入格式:**

- 第 $1$ 行: $N$ 的二进制表示, 其中一个数字写错了.

- 第 $2$ 行: $N$ 的三进制表示, 其中一个数字写错了.

**样例输入 (文件 `digits.in`):**

```txt
1010
212
```

**输入详情:**

当贝西错误地将 $N$ 转换为二进制时, 她写下了 `"1010"`. 当她错误地将 $N$ 转换为三进制时, 她写下了 `"212"`.

**输出格式:**

- 第 1 行: $N$ 的正确值.

**样例输出 (文件 `digits.out`):**

```txt
14
```

**输出详情:**

$N$ 的正确值是 $14$ (`"1110"` 在二进制中, `"112"` 在三进制中)

## 解答

定义全局的字符数组用于输入字符串.

```clojure
(common/code "cpp" (ns-name *ns*) 4 5)
```

写一个函数用于输入字符串.

```clojure
(common/code "cpp" (ns-name *ns*) 6 10)
```

> **学习 C++ 函数:**
>
> long strtol(const char\* str, char\*\* endptr, int base);
>
> 用于将字符串转换为 long 类型的数值.
>
> (根据环境不同, long 类型可能是 int 或者 long long.)
>
> - str: 要转换的字符串.
> - endptr: 一般设置为 nullptr 即可.
> - base：指定转换的进制, 可以是 $2$ 到 $36$ 之间的任意整数.

写一个函数用于解析 $k$ 进制.

```clojure
(common/code "cpp" (ns-name *ns*) 11 14)
```

> **学习进制转换算法:**
>
> 将整数转换为指定进制的字符串表示, 使用以下算法.
>
> - 不断地将整数除以进制数取余, 将余数拼接到结果字符串中.
> - 将结果字符串反转, 得到最终的字符串表示.

写一个函数用于转换为 $k$ 进制.

```clojure
(common/code "cpp" (ns-name *ns*) 15 25)
```

> **学习 Hamming 距离**
>
> Hamming 距离是用来衡量两个等长字符串之间差异的度量.
>
> 定义: 在相同位置上不同字符的数量.
>
> 作用: 通过对比两个字符串对应位置上的字符来计算它们之间的差异程度.
>
> 例如:
>
> - 对于字符串 `"hello"` 和 `"hallo"`, 它们的汉明距离为 $1$.
> - 对于字符串 `"hello"` 和 `"apple"`, 它们的汉明距离为 $4$.

写一个函数用于求 Hamming 距离, 如果字符串不等长返回 $-1$.

```clojure
(common/code "cpp" (ns-name *ns*) 26 34)
```

> **学习 `'0'` 和 `'1'` 的 ASCII 编码**
>
> - `'0'` 的 ASCII 编码是 $48$.
> - `'1'` 的 ASCII 编码是 $49$.
>
> 注意到 $48$ 和 $49$ 只有二进制最低位不同.
>
> 因此, 最简单的方式互相转化, 可以异或 $1$.

写一个函数用于把字符串下标为 $k$ 的字符翻转, $0$ 变成 $1$, $1$ 变成 $0$.

```clojure
(common/code "cpp" (ns-name *ns*) 35 36)
```

写一个函数, 测试二进制字符串转换为三进制之后, 是否与给定的三进制恰好差 $1$ 位.

如果是, 记录答案.

```clojure
(common/code "cpp" (ns-name *ns*) 37 44)
```

写一个函数用于输出一个整数.

```clojure
(common/code "cpp" (ns-name *ns*) 45 46)
```

写一个主函数. 尝试翻转二进制的每一位后, 调用上面的函数测试是否是答案.

```clojure
(common/code "cpp" (ns-name *ns*) 47 59)
```

下面是完整的程序.

```clojure
(common/code "cpp" (ns-name *ns*) 1 59)
```
